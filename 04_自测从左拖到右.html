<!--
 * @Author: Kongjingjing
 * @Date: 2022-10-26 10:14:50
 * @Description: 
-->
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>实现从简单的左侧拖动到右侧</title>
		<link rel="stylesheet" href="./04_自测从左拖到右.css" />
	</head>
	<body>
		<div id="app" class="box">
			<div class="left">
				<div id="list" class="grid">
					<img
						class="list-item"
						src="https://images.unsplash.com/photo-1531297484001-80022131f5a1?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMjA3fDB8MXxzZWFyY2h8MXx8dGVjaHxlbnwwfHx8fDE2NjIwMjM2MDQ&ixlib=rb-1.2.1&q=80&w=100"
					/>
					<img
						class="list-item"
						src="https://images.unsplash.com/photo-1488590528505-98d2b5aba04b?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMjA3fDB8MXxzZWFyY2h8Mnx8dGVjaHxlbnwwfHx8fDE2NjIwMjc1MzI&ixlib=rb-1.2.1&q=80&w=100"
					/>
					<img
						class="list-item"
						src="https://images.unsplash.com/photo-1495360010541-f48722b34f7d?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMjA3fDB8MXxzZWFyY2h8NHx8Y2F0fGVufDB8fHx8MTY2MjAyNzg3Nw&ixlib=rb-1.2.1&q=80&w=100"
					/>
					<img
						class="list-item"
						src="https://images.unsplash.com/photo-1561948955-570b270e7c36?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMjA3fDB8MXxzZWFyY2h8OHx8Y2F0fGVufDB8fHx8MTY2MjAyNzg3Nw&ixlib=rb-1.2.1&q=80&w=100"
					/>
					<img
						class="list-item"
						src="https://images.unsplash.com/photo-1519389950473-47ba0277781c?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMjA3fDB8MXxzZWFyY2h8NXx8dGVjaHxlbnwwfHx8fDE2NjIwMjc1MzI&ixlib=rb-1.2.1&q=80&w=100"
					/>
					<img
						class="list-item"
						src="https://images.unsplash.com/photo-1550745165-9bc0b252726f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMjA3fDB8MXxzZWFyY2h8Nnx8dGVjaHxlbnwwfHx8fDE2NjIwMjc1MzI&ixlib=rb-1.2.1&q=80&w=100"
					/>
					<img
						class="list-item"
						src="https://images.unsplash.com/photo-1525547719571-a2d4ac8945e2?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMjA3fDB8MXxzZWFyY2h8N3x8dGVjaHxlbnwwfHx8fDE2NjIwMjc1MzI&ixlib=rb-1.2.1&q=80&w=100"
					/>
					<img
						class="list-item"
						src="https://images.unsplash.com/photo-1579567761406-4684ee0c75b6?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMjA3fDB8MXxzZWFyY2h8OHx8dGVjaHxlbnwwfHx8fDE2NjIwMjc1MzI&ixlib=rb-1.2.1&q=80&w=100"
					/>
					<img
						class="list-item"
						src="https://images.unsplash.com/photo-1597733336794-12d05021d510?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMjA3fDB8MXxzZWFyY2h8OXx8dGVjaHxlbnwwfHx8fDE2NjIwMjc1MzI&ixlib=rb-1.2.1&q=80&w=100"
					/>
				</div>
			</div>
			<div id="content" class="content"></div>
		</div>
	</body>
	<script>
		let dragging = false // 拖曳状态
		let cloneElement = null // 克隆元素
		let initial = {} // 初始化值
		let originalElement = null
		/**
		 * @Author: Kongjingjing
		 * @Date: 2022-10-26 11:28:49
		 * @Description: 监听鼠标按下事件：1.复制一个元素出来   2. 记录鼠标的位置 3.设置是否处于拖曳状态
		 */
		document
			.getElementById('list')
			.addEventListener('mousedown', function (e) {
				e.preventDefault() // 阻止事件的默认行为
				if (e.target.classList.contains('list-item') && !cloneElement) {
					// 克隆元素
					cloneElement = e.target.cloneNode(true)
					// 设置元素浮动
					cloneElement.classList.add('flutter')
					// 将元素加到列表中
					e.target.parentElement.appendChild(cloneElement)
					// 设置可以拖动
					dragging = true
					//记录鼠标的位置
					initial.offsetX = e.offsetX
					initial.offsetY = e.offsetY
					initial.clientX = e.clientX
					initial.clientY = e.clientY
					// 本体元素的宽度
					initial.width = e.target.offsetWidth
					// 假设所有的原图大小都是200
					initial.realSize = 200
					// 处理克隆的元素的位置
					// 鼠标的位置 - 鼠标相对于元素的偏移量 = 元素的位置
					// 这样可以保证克隆体覆盖在本体上
					moveFlutter(
						initial.clientX - initial.offsetX,
						initial.clientY - initial.offsetY
					)
					// 隐藏本体，效果是拖动而不是复制
					e.target.classList.add('hide')
					originalElement = e.target
				}
			})
		/**
		 * @Author: Kongjingjing
		 * @Date: 2022-10-26 22:40:52
		 * @Description: 设置克隆元素浮动位置，缩放比例
		 * @param {*} x 横坐标
		 * @param {*} y 纵坐标
		 * @param {*} d 比例
		 */
		function moveFlutter(x, y, d = 0) {
			let scale = ''
			if (d && d + initial.width < initial.realSize) {
				scale = `transform:scale(${
					(d + initial.width) / initial.width
				})`
			}
			const options = [`left: ${x}px`, `top:${y}px`]
			scale && options.push(scale)
			// 修改克隆元素的cssText
			classStyle(options)
		}
		/**
		 * @Author: Kongjingjing
		 * @Date: 2022-10-26 20:05:06
		 * @Description: 监听鼠标移动事件
		 * @param {*} mousemove
		 * @param {*} function
		 */
		window.addEventListener('mousemove', function (e) {
			if (dragging && cloneElement) {
				moveFlutter(
					e.clientX - initial.offsetX,
					e.clientY - initial.offsetY,
					distance(e)
				)
			}
		})
		/**
		 * @Author: Kongjingjing
		 * @Date: 2022-10-27 15:00:32
		 * @Description: 监听鼠标的抬起事件
		 * @param {*} mouseup
		 * @param {*} function 鼠标抬起设置元素回到原来的位置，并且克隆的元素应该在合适的时间移出
		 */
		window.addEventListener('mouseup', function (e) {
			// 拖动结束
			dragging = false
			// 有一个回退的效果
			if (cloneElement) {
				cloneElement.classList.add('is-return')
				// 设置元素回到原来位置
				const options = [
					`left:${initial.clientX - initial.offsetX}px`,
					`top:${initial.clientY - initial.offsetY}px`,
					`transform:scalie(1)`,
				]
				classStyle(options)
				// 移出克隆的元素
				setTimeout(function () {
					//必须保存原来节点，因为这里的e.target是克隆元素
					originalElement.classList.remove('hide')
					cloneElement && cloneElement.remove()
					cloneElement = null
				}, 300)
			}
		})
		/**
		 * @Author: Kongjingjing
		 * @Date: 2022-10-27 15:01:45
		 * @Description: 使用cssText修改元素的样式
		 * @param {*} options
		 */
		function classStyle(options) {
			const original = cloneElement.style.cssText.split(';')
			//  去除多余空字符串
			original.pop()
			cloneElement.style.cssText =
				original.concat(options).join(';') + ';'
		}
		/**
		 * @Author: Kongjingjing
		 * @Date: 2022-10-27 15:26:47
		 * @Description: 两点之间的距离作为缩放比例
		 * @param {*} e
		 */
		function distance(e) {
			// 对象解构获取原始坐标
			const { clientX: x, clientY: y } = initial
			// 当前坐标
			const { clientX, clientY } = e
			// 两点之间的距离的公式
			const a = clientX - x
			const b = clientY - y
			return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2))
		}
		/**
		 * @Author: Kongjingjing
		 * @Date: 2022-10-30 15:49:08
		 * @Description: 监听画布上鼠标的抬起事件
		 */
		document
			.getElementById('content')
			.addEventListener('mouseup', function (e) {
				// 移动的位置已经有其他元素
				if (e.target.id !== 'content') {
					const lostX =
						e.x -
						document
							.getElementById('content')
							.getBoundingClientRect().left
					const lostY =
						e.y -
						document
							.getElementById('content')
							.getBoundingClientRect().top
					console.log(lostX, lostY)
					paste(lostX, lostY)
				} else {
					// 移动的位置是干净的
					paste(e.offsetX, e.offsetY)
				}
			})

		/**
		 * @Author: Kongjingjing
		 * @Date: 2022-10-27 15:46:41
		 * @Description: 在画布中粘贴元素
		 * @param {*} x 鼠标位置x
		 * @param {*} y 鼠标位置y
		 */
		function paste(x, y) {
			if (!cloneElement) {
				return
			}
			const newElement = cloneElement.cloneNode(true)
			// 移出浮动定位
			newElement.classList.remove('flutter')

			newElement.style.cssText = `left:${x - initial.offsetX}px;top:${
				y - initial.offsetY
			}px;`
			document.getElementById('content').appendChild(newElement)
			// 删除克隆元素
			cloneElement && cloneElement.remove()
			cloneElement = null
		}
	</script>
</html>
